{"version":3,"file":"attributeTable-92cc332a.js","sources":["../../node_modules/ol/format/filter/Filter.js","../../node_modules/ol/format/filter/LogicalNary.js","../../node_modules/ol/format/filter/And.js","../../node_modules/ol/format/filter/Bbox.js","../../node_modules/ol/format/filter/Comparison.js","../../node_modules/ol/format/filter/ComparisonBinary.js","../../node_modules/ol/format/filter/EqualTo.js","../../node_modules/ol/format/filter/Or.js","../../node_modules/ol/format/filter.js","../../node_modules/ol/xml.js","../../node_modules/ol/format/XMLFeature.js","../../node_modules/ol/format/GMLBase.js","../../node_modules/ol/format/xsd.js","../../node_modules/ol/format/GML2.js","../../node_modules/ol/format/GML3.js","../../node_modules/ol/format/GML32.js","../../node_modules/ol/format/WFS.js","../../components/contrib/attributeTableDAARD/attributeTable.js"],"sourcesContent":["/**\n * @module ol/format/filter/Filter\n */\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature filters.\n *\n * @abstract\n */\nclass Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   */\n  constructor(tagName) {\n    /**\n     * @private\n     * @type {!string}\n     */\n    this.tagName_ = tagName;\n  }\n\n  /**\n   * The XML tag name for a filter.\n   * @return {!string} Name.\n   */\n  getTagName() {\n    return this.tagName_;\n  }\n}\n\nexport default Filter;\n","/**\n * @module ol/format/filter/LogicalNary\n */\nimport Filter from './Filter.js';\nimport {assert} from '../../asserts.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature n-ary logical filters.\n *\n * @abstract\n */\nclass LogicalNary extends Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {Array<import(\"./Filter.js\").default>} conditions Conditions.\n   */\n  constructor(tagName, conditions) {\n    super(tagName);\n\n    /**\n     * @type {Array<import(\"./Filter.js\").default>}\n     */\n    this.conditions = conditions;\n    assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n  }\n}\n\nexport default LogicalNary;\n","/**\n * @module ol/format/filter/And\n */\nimport LogicalNary from './LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<And>` operator between two or more filter conditions.\n *\n * @abstract\n */\nclass And extends LogicalNary {\n  /**\n   * @param {...import(\"./Filter.js\").default} conditions Conditions.\n   */\n  constructor(conditions) {\n    super('And', Array.prototype.slice.call(arguments));\n  }\n}\n\nexport default And;\n","/**\n * @module ol/format/filter/Bbox\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @api\n */\nclass Bbox extends Filter {\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../../extent.js\").Extent} extent Extent.\n   * @param {string} [srsName] SRS name. No srsName attribute will be set\n   * on geometries when this is not provided.\n   */\n  constructor(geometryName, extent, srsName) {\n    super('BBOX');\n\n    /**\n     * @type {!string}\n     */\n    this.geometryName = geometryName;\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.extent = extent;\n    if (extent.length !== 4) {\n      throw new Error(\n        'Expected an extent with four values ([minX, minY, maxX, maxY])'\n      );\n    }\n\n    /**\n     * @type {string|undefined}\n     */\n    this.srsName = srsName;\n  }\n}\n\nexport default Bbox;\n","/**\n * @module ol/format/filter/Comparison\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property comparison filters.\n *\n * @abstract\n */\nclass Comparison extends Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   */\n  constructor(tagName, propertyName) {\n    super(tagName);\n\n    /**\n     * @type {!string}\n     */\n    this.propertyName = propertyName;\n  }\n}\n\nexport default Comparison;\n","/**\n * @module ol/format/filter/ComparisonBinary\n */\nimport Comparison from './Comparison.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property binary comparison filters.\n *\n * @abstract\n */\nclass ComparisonBinary extends Comparison {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean} [matchCase] Case-sensitive?\n   */\n  constructor(tagName, propertyName, expression, matchCase) {\n    super(tagName, propertyName);\n\n    /**\n     * @type {!(string|number)}\n     */\n    this.expression = expression;\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = matchCase;\n  }\n}\n\nexport default ComparisonBinary;\n","/**\n * @module ol/format/filter/EqualTo\n */\nimport ComparisonBinary from './ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsEqualTo>` comparison operator.\n * @api\n */\nclass EqualTo extends ComparisonBinary {\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean} [matchCase] Case-sensitive?\n   */\n  constructor(propertyName, expression, matchCase) {\n    super('PropertyIsEqualTo', propertyName, expression, matchCase);\n  }\n}\n\nexport default EqualTo;\n","/**\n * @module ol/format/filter/Or\n */\nimport LogicalNary from './LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<Or>` operator between two ore more filter conditions.\n * @api\n */\nclass Or extends LogicalNary {\n  /**\n   * @param {...import(\"./Filter.js\").default} conditions Conditions.\n   */\n  constructor(conditions) {\n    super('Or', Array.prototype.slice.call(arguments));\n  }\n}\n\nexport default Or;\n","/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport DWithin from './filter/DWithin.js';\nimport Disjoint from './filter/Disjoint.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport ResourceId from './filter/ResourceId.js';\nimport Within from './filter/Within.js';\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @return {!And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params))();\n}\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @return {!Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params))();\n}\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @return {!Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, srsName) {\n  return new Bbox(geometryName, extent, srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, srsName) {\n  return new Contains(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, srsName) {\n  return new Intersects(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<Disjoint>` operator to test whether a geometry-valued property\n * is disjoint to a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Disjoint} `<Disjoint>` operator.\n * @api\n */\nexport function disjoint(geometryName, geometry, srsName) {\n  return new Disjoint(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, srsName) {\n  return new Within(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<DWithin>` operator to test whether a geometry-valued property\n * is within a distance to a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {!number} distance Distance.\n * @param {!string} unit Unit.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!DWithin} `<DWithin>` operator.\n * @api\n */\nexport function dwithin(geometryName, geometry, distance, unit, srsName) {\n  return new DWithin(geometryName, geometry, distance, unit, srsName);\n}\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean} [matchCase] Case-sensitive?\n * @return {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, matchCase) {\n  return new EqualTo(propertyName, expression, matchCase);\n}\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean} [matchCase] Case-sensitive?\n * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, matchCase) {\n  return new NotEqualTo(propertyName, expression, matchCase);\n}\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @return {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @return {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string} [wildCard] Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string} [singleChar] pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string} [escapeChar] Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean} [matchCase] Case-sensitive?\n * @return {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(\n  propertyName,\n  pattern,\n  wildCard,\n  singleChar,\n  escapeChar,\n  matchCase\n) {\n  return new IsLike(\n    propertyName,\n    pattern,\n    wildCard,\n    singleChar,\n    escapeChar,\n    matchCase\n  );\n}\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @return {!During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n\nexport function resourceId(rid) {\n  return new ResourceId(rid);\n}\n","/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(\n      thisArg !== undefined ? thisArg : this,\n      node,\n      value,\n      objectStack\n    );\n    const parent = /** @type {NodeStackItem} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg !== undefined ? thisArg : this,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n","/**\n * @module ol/format/XMLFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\nimport {extend} from '../array.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeatureFromNode(/** @type {Element} */ (source), options);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeaturesFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options)\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readGeometryFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readProjectionFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n","/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport {extend} from '../array.js';\nimport {\n  getAllTextContent,\n  getAttributeNS,\n  makeArrayPusher,\n  makeReplacer,\n  parseNode,\n  pushParseAndPop,\n} from '../xml.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal),\n    };\n\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop(\n        [],\n        this.FEATURE_COLLECTION_PARSERS,\n        node,\n        objectStack,\n        this\n      );\n    } else if (\n      localName == 'featureMembers' ||\n      localName == 'featureMember' ||\n      localName == 'member'\n    ) {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        (featureType = []), (featureNS = {});\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */ (node.childNodes[i]);\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType)\n        ? featureType\n        : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':')\n            ? featureTypes[i].split(':')[0]\n            : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n              localName == 'featureMembers'\n                ? makeArrayPusher(this.readFeatureElement, this)\n                : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] =\n      node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const extent = /** @type {import(\"../extent.js\").Extent} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return geometry\n      ? transformGeometryWithOptions(geometry, false, context)\n      : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (\n        n.childNodes.length === 0 ||\n        (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))\n      ) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value =\n            localName === 'boundedBy'\n              ? this.readExtentElement(n, objectStack)\n              : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      const len = n.attributes.length;\n      if (len > 0) {\n        value = {_content_: value};\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    } else {\n      const feature = new Feature(values);\n      if (geometryName) {\n        feature.setGeometryName(geometryName);\n      }\n      const fid =\n        node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n      if (fid) {\n        feature.setId(fid);\n      }\n      return feature;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop(\n      [],\n      this.MULTIPOINT_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTILINESTRING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTIPOLYGON_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (ring) {\n      return ring;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [\n      this.getReadOptions(node, options ? options : {}),\n    ]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS,\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return getProjection(\n      this.srsName\n        ? this.srsName\n        : node.firstElementChild.getAttribute('srsName')\n    );\n  }\n}\n\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n  },\n};\n\nexport default GMLBase;\n","/**\n * @module ol/format/xsd\n */\nimport {getAllTextContent, getDocument} from '../xml.js';\nimport {padNumber} from '../string.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(getDocument().createTextNode(string));\n}\n","/**\n * @module ol/format/GML2\n */\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  createElementNS,\n  getAllTextContent,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {createOrUpdate} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport {writeStringTextNode} from './xsd.js';\n\n/**\n * @const\n * @type {string}\n */\nconst schemaLocation =\n  GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @api\n */\nclass GML2 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(\n      this.readFeaturesInternal\n    );\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatCoordinates(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n      objectStack[0]\n    );\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    const coordsGroups = s.trim().split(/\\s+/);\n    const flatCoordinates = [];\n    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n      const coords = coordsGroups[i].split(/,+/);\n      const x = parseFloat(coords[0]);\n      const y = parseFloat(coords[1]);\n      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readBox(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.BOX_PARSERS_,\n      node,\n      objectStack,\n      this\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[1][3],\n      flatCoordinates[1][4]\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  innerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  outerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml', nodeName);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @return {Element} coordinates node.\n   * @private\n   */\n  createCoordinatesNode_(namespaceURI) {\n    const coordinates = createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n\n    return coordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LineString.js\").default|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCoordinates_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      const point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs'\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ',' + point[1]\n        : point[1] + ',' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ',' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    const point = geometry.getCoordinates();\n    const coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates, coord);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      'http://www.opengis.net/gml',\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML2.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML2.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\nexport default GML2;\n","/**\n * @module ol/format/GML3\n */\nimport GML2 from './GML2.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {createOrUpdate} from '../extent.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation =\n  GMLNS +\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n  '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ =\n      options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ =\n      options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Polygon.\n   */\n  readFlatCurveRing(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    const flatCoordinates = [];\n    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n      extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTISURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.PATCHES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.SURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.CURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.ENVELOPE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[2][0],\n      flatCoordinates[2][1]\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n    ) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n      );\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ' ' + point[1]\n        : point[1] + ' ' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior'\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement,\n      this\n    );\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS),\n      features,\n      objectStack\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeGeometryNode(geometry, options) {\n    options = this.adaptOptions(options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Element} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation\n    );\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML3;\n","/**\n * @module ol/format/GML32\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase from './GMLBase.js';\nimport {\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n} from '../xml.js';\nimport {writeStringTextNode} from '../format/xsd.js';\n\n/**\n * @classdesc Feature format for reading and writing data in the GML format\n *            version 3.2.1.\n * @api\n */\nclass GML32 extends GML3 {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';\n  }\n}\n\nGML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML32.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML32.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML32.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML32.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML32.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML32;\n","/**\n * @module ol/format/WFS\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GML32 from './GML32.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  isDocument,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeSimpleNodeFactory,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {and as andFilterFn, bbox as bboxFilterFn} from './filter.js';\nimport {assert} from '../asserts.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readNonNegativeIntegerString,\n  readPositiveInteger,\n  writeStringTextNode,\n} from './xsd.js';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readExtentElement,\n      'bounds'\n    ),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'member': makeArrayPusher(GMLBase.prototype.readFeaturesInternal),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary'\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary'\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n};\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.\n * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to\n * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are\n * ignored.).\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`\n * option must be set.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} FeatureType\n * @property {!string} name The feature type name.\n * @property {!import(\"../extent.js\").Extent} bbox Extent to use for the BBOX filter.\n * @property {!string} geometryName Geometry name to use in the BBOX filter.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures NumberOfFeatures.\n * @property {import(\"../extent.js\").Extent} bounds Bounds.\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted TotalDeleted.\n * @property {number} totalInserted TotalInserted.\n * @property {number} totalUpdated TotalUpdated.\n * @property {Array<string>} insertIds InsertIds.\n */\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @type {Object<string, string>}\n */\nconst OGCNS = {\n  '2.0.0': 'http://www.opengis.net/ogc/1.1',\n  '1.1.0': 'http://www.opengis.net/ogc',\n  '1.0.0': 'http://www.opengis.net/ogc',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst WFSNS = {\n  '2.0.0': 'http://www.opengis.net/wfs/2.0',\n  '1.1.0': 'http://www.opengis.net/wfs',\n  '1.0.0': 'http://www.opengis.net/wfs',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst FESNS = {\n  '2.0.0': 'http://www.opengis.net/fes/2.0',\n  '1.1.0': 'http://www.opengis.net/fes',\n  '1.0.0': 'http://www.opengis.net/fes',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '2.0.0':\n    'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',\n  '1.1.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd',\n};\n\n/**\n * @type {Object<string, object>}\n */\nconst GML_FORMATS = {\n  '2.0.0': GML32,\n  '1.1.0': GML3,\n  '1.0.0': GML2,\n};\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option to override the default.\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version ? options.version : DEFAULT_VERSION;\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat\n      ? options.gmlFormat\n      : new GML_FORMATS[this.version_]();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation\n      ? options.schemaLocation\n      : SCHEMA_LOCATIONS[this.version_];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    Object.assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_,\n    });\n\n    Object.assign(context, this.getReadOptions(node, options ? options : {}));\n    const objectStack = [context];\n    let featuresNS;\n    if (this.version_ === '2.0.0') {\n      featuresNS = FEATURE_COLLECTION_PARSERS;\n    } else {\n      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;\n    }\n    let features = pushParseAndPop(\n      [],\n      featuresNS,\n      node,\n      objectStack,\n      this.gmlFormat_\n    );\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readTransactionResponseFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(\n          /** @type {Element} */ (n)\n        );\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures')\n    );\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS,\n      node,\n      [],\n      this.gmlFormat_\n    );\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {TransactionResponse} */ ({}),\n      TRANSACTION_RESPONSE_PARSERS,\n      node,\n      []\n    );\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS[this.version_], 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', this.version_);\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n    if (options.outputFormat) {\n      node.setAttribute('outputFormat', options.outputFormat);\n    }\n    if (options.maxFeatures !== undefined) {\n      node.setAttribute('maxFeatures', String(options.maxFeatures));\n    }\n    if (options.resultType) {\n      node.setAttribute('resultType', options.resultType);\n    }\n    if (options.startIndex !== undefined) {\n      node.setAttribute('startIndex', String(options.startIndex));\n    }\n    if (options.count !== undefined) {\n      node.setAttribute('count', String(options.count));\n    }\n    if (options.viewParams !== undefined) {\n      node.setAttribute('viewParams', options.viewParams);\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation_\n    );\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    Object.assign(context, {\n      'version': this.version_,\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'propertyNames': options.propertyNames ? options.propertyNames : [],\n    });\n    assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` must be an Array\n    if (typeof options.featureTypes[0] === 'string') {\n      let filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\n        filter = this.combineBboxAndFilter(\n          options.geometryName,\n          options.bbox,\n          options.srsName,\n          filter\n        );\n      }\n      Object.assign(context, {\n        'geometryName': options.geometryName,\n        'filter': filter,\n      });\n      writeGetFeature(\n        node,\n        /** @type {!Array<string>} */ (options.featureTypes),\n        [context]\n      );\n    } else {\n      // Write one query node per element in featuresType.\n      options.featureTypes.forEach((/** @type {FeatureType} */ featureType) => {\n        const completeFilter = this.combineBboxAndFilter(\n          featureType.geometryName,\n          featureType.bbox,\n          options.srsName,\n          options.filter\n        );\n        Object.assign(context, {\n          'geometryName': featureType.geometryName,\n          'filter': completeFilter,\n        });\n        writeGetFeature(node, [featureType.name], [context]);\n      });\n    }\n    return node;\n  }\n\n  /**\n   * Create a bbox filter and combine it with another optional filter.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../extent.js\").Extent} extent Extent.\n   * @param {string} [srsName] SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @param {import(\"./filter/Filter.js\").default} [filter] Filter condition.\n   * @return {import(\"./filter/Filter.js\").default} The filter.\n   */\n  combineBboxAndFilter(geometryName, extent, srsName, filter) {\n    const bboxFilter = bboxFilterFn(geometryName, extent, srsName);\n    if (filter) {\n      // if bbox and filter are both set, combine the two into a single filter\n      return andFilterFn(filter, bboxFilter);\n    }\n    return bboxFilter;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const version = options.version ? options.version : this.version_;\n    const node = createElementNS(WFSNS[version], 'Transaction');\n\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATIONS[version]\n    );\n\n    const request = createTransactionRequest(node, baseObj, version, options);\n    if (inserts) {\n      serializeTransactionRequest('Insert', inserts, objectStack, request);\n    }\n    if (updates) {\n      serializeTransactionRequest('Update', updates, objectStack, request);\n    }\n    if (deletes) {\n      serializeTransactionRequest('Delete', deletes, objectStack, request);\n    }\n    if (options.nativeElements) {\n      serializeTransactionRequest(\n        'Native',\n        options.nativeElements,\n        objectStack,\n        request\n      );\n    }\n    return node;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (\n          !(\n            n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 && n.firstChild.nodeType === 3)\n          )\n        ) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {*} baseObj Base object.\n * @param {string} version Version.\n * @param {WriteTransactionOptions} options Options.\n * @return {Object} Request object.\n */\nfunction createTransactionRequest(node, baseObj, version, options) {\n  const featurePrefix = options.featurePrefix\n    ? options.featurePrefix\n    : FEATURE_PREFIX;\n  let gmlVersion;\n  if (version === '1.0.0') {\n    gmlVersion = 2;\n  } else if (version === '1.1.0') {\n    gmlVersion = 3;\n  } else if (version === '2.0.0') {\n    gmlVersion = 3.2;\n  }\n  const obj = Object.assign(\n    {node},\n    {\n      version,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'hasZ': options.hasZ,\n      'srsName': options.srsName,\n    },\n    baseObj\n  );\n  return obj;\n}\n\n/**\n * @param {string} type Request type.\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @param {Element} request Transaction Request.\n */\nfunction serializeTransactionRequest(type, features, objectStack, request) {\n  pushSerializeAndPop(\n    request,\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory(type),\n    features,\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n  'http://www.opengis.net/ogc/1.1': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser,\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Feature': fidParser,\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else if (gmlVersion === 3) {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML32.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = OGCNS[version];\n  const filter = createElementNS(ns, 'Filter');\n  const child = createElementNS(ns, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */ (fid));\n  node.appendChild(filter);\n}\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @return {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.startsWith(prefix)) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const version = context['version'];\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (\n          value &&\n          typeof (/** @type {?} */ (value).getSimplifiedGeometry) === 'function'\n        ) {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */ ({\n        version,\n        'gmlVersion': context['gmlVersion'],\n        node,\n        'hasZ': context['hasZ'],\n        'srsName': context['srsName'],\n      }),\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Property'),\n      values,\n      objectStack\n    );\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = WFSNS[version];\n  const name = createElementNS(ns, 'Name');\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(ns, 'Value');\n    node.appendChild(value);\n    if (\n      pair.value &&\n      typeof (/** @type {?} */ (pair.value).getSimplifiedGeometry) ===\n        'function'\n    ) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else if (gmlVersion === 3) {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML32.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n  'http://www.opengis.net/fes/2.0': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Disjoint': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'ResourceId': makeChildAppender(writeResourceIdFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const version = context['version'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  let typeNameAttr;\n  if (version === '2.0.0') {\n    typeNameAttr = 'typeNames';\n  } else {\n    typeNameAttr = 'typeName';\n  }\n  node.setAttribute(typeNameAttr, typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    Object.assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'),\n    propertyNames,\n    objectStack\n  );\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(getFilterNS(version), 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter],\n    objectStack\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n/**\n * @param {Element} node Element.\n * @param {import(\"./filter/ResourceId.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeResourceIdFilter(node, filter, objectStack) {\n  node.setAttribute('rid', /** @type {string} */ (filter.rid));\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Spatial.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeSpatialFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/DWithin.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDWithinFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writeSpatialFilter(node, filter, objectStack);\n  const distance = createElementNS(getFilterNS(version), 'Distance');\n  writeStringTextNode(distance, filter.distance.toString());\n  if (version === '2.0.0') {\n    distance.setAttribute('uom', filter.unit);\n  } else {\n    distance.setAttribute('units', filter.unit);\n  }\n  node.appendChild(distance);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n\n  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(\n      item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition],\n      objectStack\n    );\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  const condition = filter.condition;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition],\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.expression);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writePropertyName(version, node, filter.propertyName);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  const ns = getFilterNS(version);\n\n  writePropertyName(version, node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(ns, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(ns, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.pattern);\n}\n\n/**\n * @param {string} ns Namespace.\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeExpression(ns, tagName, node, value) {\n  const property = createElementNS(ns, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeLiteral(version, node, value) {\n  writeExpression(getFilterNS(version), 'Literal', node, value);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writePropertyName(version, node, value) {\n  if (version === '2.0.0') {\n    writeExpression(FESNS[version], 'ValueReference', node, value);\n  } else {\n    writeExpression(OGCNS[version], 'PropertyName', node, value);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {string} version WFS version. If not provided defaults to '1.1.0'\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter, version) {\n  version = version || '1.1.0';\n  const child = createElementNS(getFilterNS(version), 'Filter');\n  const context = {\n    node: child,\n  };\n  Object.assign(context, {\n    'version': version,\n    'filter': filter,\n  });\n  writeFilterCondition(child, filter, [context]);\n  return child;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    Object.assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'),\n    featureTypes,\n    objectStack\n  );\n}\n\nfunction getFilterNS(version) {\n  let ns;\n  if (version === '2.0.0') {\n    ns = FESNS[version];\n  } else {\n    ns = OGCNS[version];\n  }\n  return ns;\n}\n\nexport default WFS;\n","import './attributeTable.css';\n\nimport { and, equalTo, or } from 'ol/format/filter';\nimport { boundingExtent, getCenter } from 'ol/extent';\nimport { emitCustomEvent, getBaseUrl, isValidUrl } from '../../core/helper.js'\nimport { featureLayersGroup, map } from '../../core/mapSetup/mapSetup.js'\n\nimport Alpine from 'alpinejs';\nimport { WFS } from 'ol/format';\nimport { decorateValue } from '../../core/contentDecorator/contentDecorator.js';\nimport feather from 'feather-icons';\nimport {renderMarkupAndSetPluginReady} from '../../core/helper.js'\n\nconst parseFilterCondition = (condition) => {\n  const match = condition.match(/\"([^\"]+)\"='([^']+)'/);\n  return equalTo(match[1], match[2]);\n};\n\nvar fetchFeatureData = (layerName, filterString) => {\n  const Layer = featureLayersGroup.getLayers().getArray().find(layer => layer.get('name') === layerName);\n  const LayerParams = Layer.getSource().getParams().LAYERS;\n  const baseurl = getBaseUrl(featureLayersGroup.getLayers().getArray().find(layer => layer.get('name') === layerName).getSource().url_);\n\n  // Construct the feature request\n  let featureRequestOptions = {\n    srsName: 'EPSG:3857',\n    featurePrefix: 'geonode',\n    featureTypes: [LayerParams],\n    outputFormat: 'application/json'\n  };\n\n  // Parse the filter string and construct filter objects\n  if (filterString && typeof filterString === 'string' && filterString.trim() !== '') {\n    let filters;\n    if (filterString.includes(' AND ')) {\n      // Process AND conditions\n      filters = filterString.split(' AND ').map(parseFilterCondition);\n      featureRequestOptions.filter = and(...filters);\n    } else if (filterString.includes(' OR ')) {\n      // Process OR conditions\n      filters = filterString.split(' OR ').map(parseFilterCondition);\n      featureRequestOptions.filter = or(...filters);\n    } else {\n      // Process a single condition\n      const singleFilter = parseFilterCondition(filterString);\n      featureRequestOptions.filter = singleFilter;\n    }\n  }\n\n  console.warn(\"Options are \", featureRequestOptions)\n\n\n  const featureRequest = new WFS().writeGetFeature(featureRequestOptions);\n\n  return fetch(`${baseurl}wfs`, {\n    method: 'POST',\n    body: new XMLSerializer().serializeToString(featureRequest),\n    headers: {\n      'Content-Type': 'text/xml',\n    },\n  })\n  .then(response => response.json());\n}\n\n\n\n\n\nconst createMarkup = () => {\n  // Plugin HTML Markup\n  const attributeTableNaavigationBtn = `\n      <div class=\"mx-1  order-2\">\n      <button\n        type=\"button\" \n        class=\"btn btn-danger btn-sm btn-circle\" \n        id=\"attributeTableBtn\" \n        x-tooltip.placement.left=\"'Attribute table'\"\n        @click=\"$store.attributeTable.process_attribute_table()\"\n        :class=\"$store.attributeTable.componentIsActive ? 'bg-danger' : 'btn-light'\">\n        <i data-feather=\"list\" class=\"size-16\"></i>\n\n      </button>\n    </div>\n      `\n\n  var rightMiddleSlot = document.getElementById('rightMiddleSlot');\n  rightMiddleSlot.insertAdjacentHTML('beforeend', attributeTableNaavigationBtn);\n\n  const attributeTableSlideOutHtml = `\n    <div id=\"attributeTable\" class=\"position-absolute bottom-0 end-0 p-0 bg-white border-top px-1\" style=\"width: 100%; height: 40vh; z-index:1000\" x-show=\"$store.attributeTable.componentIsActive\">\n      <div class=\"offcanvas-header d-flex justify-content-between align-items-center px-3 mt-3\">\n          <div class=\"d-flex align-items-center\">\n              <!-- Layer Selection -->\n              <div class=\"layer-select-container me-2\">\n                  <select id=\"layerSelect\" class=\"form-select form-select-sm\">\n                      <template x-for=\"option in $store.attributeTable.visisbleLayers\"> \n                          <option :value=\"option.get('name')\" x-text=\"option.get('name')\"></option>\n                      </template>\n                  </select>\n              </div>\n              <!-- Row Count Selection -->\n              <div class=\"ms-2\"> \n                  <select x-model=\"$store.attributeTable.rowCount\" class=\"form-select form-select-sm\" id=\"rowCountSelect\">\n                      <option value=\"5\">5</option>\n                      <option value=\"10\">10</option>\n                      <option value=\"50\">50</option>\n                  </select>\n              </div>\n          </div>\n\n          <div class=\"d-flex align-items-center\">\n              <!-- Items Shown Indicator -->\n              <p class=\"mb-0 mx-3\" x-text=\"$store.attributeTable.filteredFeatures().length + ' items shown'\"></p>\n           \n              <!-- Search Input -->\n              <div class=\"d-flex me-2\">\n                  <label for=\"searchInput\" class=\"me-2 mb-0\"><i class=\"bi bi-search\"></i></label>\n                  <input type=\"text\" id=\"searchInput\" class=\"form-control form-control-sm\" placeholder=\"Search...\" x-model=\"$store.attributeTable.searchQuery\" style=\"width: 200px;\">\n              </div>\n\n              <!-- Close Button -->\n              <button type=\"button\" class=\"btn-close\" aria-label=\"Close\" @click=\"$store.attributeTable.closePanel()\"></button>\n          </div>\n      </div>\n\n            <div class=\"offcanvas-body mt-4 px-3\" id=\"attributeTableBody\">\n\n              <!-- table -->\n              <div style=\"width: 100%; overflow-y: auto;\">\n\n              <!-- Alpine.js Component for Feature Properties Table -->\n              <div x-cloak>\n                <template x-if=\"!$store.attributeTable.fetchSuccessful\">\n                  <p>Sorry, no items received.</p>\n                </template>\n\n                <template x-if=\"$store.attributeTable.fetchSuccessful\">\n                  <table class=\"attributesTable table table-sm table-striped mb-0\" id=\"attributesTable\">\n                    <thead>\n                        <tr>\n                          <th>\n                            <span class=\"attributTable_col\" x-text=\"''\"></span>\n                          </th>\n                          <template x-if=\"$store.attributeTable.features.length > 0\">\n                            <template x-for=\"key in Object.keys($store.attributeTable.features[0].properties)\" :key=\"key\">\n                              <th>\n                                <span class=\"attributTable_col\" x-text=\"$store.attributeTable.getKeyTranslation(key)\"></span>\n                              </th>\n                            </template>\n                          </template>\n                        </tr>\n                      </thead>\n                      <tbody>\n                          <template x-for=\"feature in $store.attributeTable.paginatedFeatures()\" :key=\"feature.id\">\n                          <tr :class=\"$store.attributeTable.activeFeatures.includes(String(feature.properties['fid'])) ? 'highlight-row' : ''\">\n                            <td>\n                            <p x-show=\"!$store.attributeTable.activeFeatures.includes(String(feature.properties['fid']))\">\n                              <a href=\"#\" :data-id=\"feature.properties['fid']\" @click=\"$store.attributeTable.zoomTo()\" >\n                                  <i data-feather=\"map-pin\" class=\"size-16\"></i>\n                              </a>      \n                            </p>\n\n                            <p x-show=\"$store.attributeTable.activeFeatures.includes(String(feature.properties['fid']))\">\n                              <a href=\"#\" :data-id=\"feature.properties['fid']\" @click=\"$store.attributeTable.zoomTo()\" >\n                                <i data-feather=\"check\" class=\"size-16\"></i>\n                              </a>      \n                            </p>\n\n                            </td>\n                            <template x-for=\"[key, value] in Object.entries(feature.properties)\" :key=\"key\">\n                              <td class=\"attributTableTD\">\n                                <span class=\"attributTable_col\" x-html=\"$store.attributeTable.decorateValue(value)\"> </span>\n                              </td>\n                            </template>\n                          </tr>\n                        </template>\n                      </tbody>\n                  </table>\n                </template>\n                \n              </div>\n\n\n            \n            </div>\n            <!-- Pagination -->\n            <template x-if=\"$store.attributeTable.fetchSuccessful\">\n\n              <nav aria-label=\"Page navigation\">\n                <ul class=\"pagination pagination-sm justify-content-end mt-3\">\n                  <!-- First Page Link -->\n                  <li class=\"page-item\" :class=\"{ disabled: $store.attributeTable.currentPage === 1 }\">\n                    <a class=\"page-link\" href=\"#\" @click.prevent=\"$store.attributeTable.setFirstPage()\">\n                      First\n                    </a>\n                  </li>\n              \n                  <!-- Dynamic Page Links -->\n                  <template x-for=\"page in $store.attributeTable.pageRange()\" :key=\"page\">\n                    <li class=\"page-item\" :class=\"{ active: $store.attributeTable.currentPage === page }\">\n                      <a class=\"page-link\" href=\"#\" x-text=\"page\" @click.prevent=\"$store.attributeTable.setPage(page)\">\n                      </a>\n                    </li>\n                  </template>\n              \n                  <!-- Last Page Link -->\n                  <li class=\"page-item\" :class=\"{ disabled: $store.attributeTable.currentPage === $store.attributeTable.totalPages() }\">\n                    <a class=\"page-link\" href=\"#\" @click.prevent=\"$store.attributeTable.setLastPage()\">\n                      Last\n                    </a>\n                  </li>\n                </ul>\n              </nav>\n              </template>\n    </div>\n  </div>\n\n  `\n  var mapDIV = document.getElementById('map');\n  mapDIV.insertAdjacentHTML('afterend', attributeTableSlideOutHtml);\n\n\n}\n\n\n// Initialize the plugin\nconst initialize = () => {\n\n  Alpine.store('attributeTable', {\n    componentIsActive: false,\n    visisbleLayers: [],\n    features: [],\n    filterString: \"\",\n    activeFeatures: [],\n    isValidUrl: function(value){\n      return isValidUrl(value);\n    },\n\n    zoomToCoordinates: [],\n    closePanel: function(){\n      emitCustomEvent('deleteMapPins', {});\n      this.componentIsActive = false;\n      this.activeFeatures = [];\n      this.zoomToCoordinates = [];\n      Alpine.store('pluginStatus').mapClickEnabled = true;\n\n    },\n    zoomTo: function(){\n        const featureId = event.target.closest('a').getAttribute(\"data-id\")\n        const feature = this.features.find(f => f.properties['fid'] == featureId);\n\n        if (feature) {\n          const geometry = feature.geometry;\n          let extent;\n          let center;\n          if (this.activeFeatures.includes(featureId)) {\n              this.activeFeatures = this.activeFeatures.filter(function(e) { return e !== featureId })\n          } else {\n              this.activeFeatures.push(featureId);\n          }\n\n    \n          switch (geometry.type) {\n            case 'Point':\n              center = geometry.coordinates;\n              const buffer = 100; // Adjust buffer size as needed\n              extent = [\n                geometry.coordinates[0] - buffer, \n                geometry.coordinates[1] - buffer, \n                geometry.coordinates[0] + buffer, \n                geometry.coordinates[1] + buffer\n              ];\n              var maxZoom = 13;\n              break;\n    \n            case 'Polygon':\n              extent = boundingExtent(geometry.coordinates[0].flat());\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            case 'MultiPolygon':\n              const allPolygons = geometry.coordinates.flat(2);\n              extent = boundingExtent(allPolygons);\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            case 'LineString':\n              extent = boundingExtent(geometry.coordinates);\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            case 'MultiLineString':\n              const allLines = geometry.coordinates.flat();\n              extent = boundingExtent(allLines);\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            default:\n              console.error('Unsupported geometry type:', geometry.type);\n              return;\n          }\n    \n          if (extent) {\n\n            const coordIndex = this.zoomToCoordinates.findIndex(coord => \n                coord[0] === center[0] && coord[1] === center[1]\n            );\n\n            if (coordIndex === -1) {\n                // Coordinate not found, add it\n                this.zoomToCoordinates.push([center[0], center[1]]);\n            } else {\n                // Coordinate found, remove it\n                this.zoomToCoordinates.splice(coordIndex, 1);\n            }\n\n            emitCustomEvent('deleteMapPins', {});\n            emitCustomEvent('addMapPins', {\"pin_coordinates\": this.zoomToCoordinates, \"fitView\": true, moveCenterLeft: false, bottomPadding: '40vh'});\n        }\n        }\n      \n    },\n    searchQuery: '',\n    rowCount: 5,\n    currentPage: 1,\n    fetchSuccessful: false,\n    decorateValue: function(value) {\n      const decoratedValue = decorateValue(value, ['createLinkForUrl', 'decodeUrl', 'harmonizeUnknown', 'replaceBulletwithComma', 'replaceUndefined']);\n      return decoratedValue;\n    },\n    blockedKeys: [\n      'c_b_t_bc_rel', \n      'svgid', \n      'c_bones', \n      'bone_relations', \n      'age', \n      'adults', \n      'subadults',\n      'c_no_o_bones',\n      'published',\n      'gaz_link',\n      'gazid',\n      'owner',\n      'is_approved',\n      'text'\n    ],\n    keyTranslations: {\n      \"disease\": \"Disease\",\n      \"sex\": \"Sex\",\n      \"sex_freetext\": \"Methods for sex determination\",\n      \"age\": \"Age\",\n      \"age_class\": \"Age class\",\n      \"age_estimation_method\": \"Methods for age estimation\",\n      \"age_freetext\": \"Age comment\",\n      \"adults\": \"Adults\",\n      \"size_from\": \"Body height from (cm)\",\n      \"size_to\": \"Body height to (cm)\",\n      \"size_freetext\": \"Methods for body height calculation\",\n      \"chronology\": \"Time period\",\n      \"chronology_freetext\": \"Time period comment\",\n      \"dating_method\": \"Dating method\",\n      \"subadults\": \"Subadults\",\n      \"c_no_o_bones\": \"Amount of bones\",\n      \"c_technic\": \"Used Technic\",\n      \"doi\": \"Doi\",\n      \"differential_diagnosis\": \"Differential Diagnosis\",\n      \"dna_analyses\": \"aDNA analyses\",\n      \"dna_analyses_link\": \"DNA analyses\",\n      \"storage_place\": \"Storage place\",\n      \"storage_place_freetext\": \"Storage place freetext\",\n      \"archaeological_burial_type\": \"Archaeological burial type\",\n      \"archaeological_funery_context\": \"Archaeological funerary context\",\n      \"archaeological_individualid\": \"Archaeological individual ID\",\n      \"archaeological_tombid\": \"Archaeological tomb ID\",\n      \"gaz_link\": \"iDAI.gazetteer link\",\n      \"gazid\": \"iDAI.gazetteer ID\",\n      \"site\": \"Site\",\n      \"origin\": \"Origin\",\n      \"reference_images\": \"Reference images\",\n      \"references\": \"References\",\n      \"uuid\": \"UUID\",\n      \"owner\": \"Owner\",\n      \"fid\": \"Datbase ID\",\n      \"comment\": \"Comment\",\n      \"fid\": \"File ID\",\n      \"uid\": \"UUID\"\n    },\n    getKeyTranslation: function(value){\n      const translatedKey = this.keyTranslations[value] || value;\n      return translatedKey\n    },\n    filteredFeatures: function() {\n      feather.replace();\n\n      const query = this.searchQuery.toLowerCase();\n      const filtered = this.features.filter(feature => {\n        return Object.entries(feature.properties).some(([key, value]) => {\n          if (typeof value === 'string' || typeof value === 'number') {\n            return value.toString().toLowerCase().includes(query);\n          }\n          return false;\n        });\n      });\n\n      // WORKAROUND: Inform the DAARD Filter component about current found features.\n      Alpine.store('geonodeCustomLayerFilter').layerFeaturesOnMap['Daard Database'] = filtered.length\n\n      return filtered;\n    },\n\n    // New function to get the features for the current page\n    paginatedFeatures: function() {\n      const start = (this.currentPage - 1) * this.rowCount;\n      const end = start + Number(this.rowCount);\n      const paginated = this.filteredFeatures().slice(start, end);\n      console.log(`Paginated Features: Current Page = ${this.currentPage}, Row Count = ${this.rowCount}, Start = ${start}, End = ${end}, Count = ${paginated.length}`);\n      return paginated;\n    },\n\n    // Adjust totalPages to use the length of filteredFeatures instead of paginatedFeatures\n    totalPages: function() {\n      const filteredCount = this.filteredFeatures().length;\n      return Math.ceil(filteredCount / this.rowCount);\n    },\n    setPage: function(page) {\n      this.currentPage = page;\n    },\n\n    pageRange: function() {\n      const range = 2; // Number of pages to display around the current page\n      const start = Math.max(1, this.currentPage - range);\n      const end = Math.min(this.totalPages(), this.currentPage + range);\n    \n      let pages = [];\n  \n      for (let i = start; i <= end; i++) {\n        pages.push(i);\n      }\n  \n      return pages;\n    },\n  \n    setFirstPage: function() {\n      this.currentPage = 1;\n    },\n\n    setLastPage: function() {\n      this.currentPage = this.totalPages();\n    },\n  \n    setPage: function(page) {\n      this.currentPage = page;\n      console.log(`Set Page: Current Page Set to = ${page}`);\n    },\n    \n    process_attribute_table: function() {\n      Alpine.store('pluginStatus').closeAllOffcanvas('attributeTable');\n      this.componentIsActive = !this.componentIsActive;\n      Alpine.store('pluginStatus').mapClickEnabled = this.componentIsActive ? false : true;\n\n      this.populateLayerSelect();\n    },\n\n    populateLayerSelect: function() {\n      const visibleLayers = featureLayersGroup.getLayers().getArray().filter(layer => layer.getVisible());\n      this.visisbleLayers = visibleLayers;\n      if (visibleLayers.length > 0) {\n        this.selectedLayer = visibleLayers[0].get('name');\n        this.updateTableForLayer(this.selectedLayer); // Load table for the first layer\n      }\n    },\n\n    updateRowCount: function() {\n      this.currentPage = 1;\n      console.log(`Row Count Updated: New Row Count = ${this.rowCount}, Current Page Reset to = ${this.currentPage}`);\n    },\n\n    updateTableForLayer: function(layerName = null) {\n      console.log(\"updating with: \", this.filterString);\n      this.currentTable = true;\n      const selectedLayer = layerName || document.getElementById('layerSelect').value;\n      const Layer = featureLayersGroup.getLayers().getArray().find(layer => layer.get('name') === selectedLayer);\n    \n      this.activeFeatures = [];\n      this.zoomToCoordinates = [];\n      emitCustomEvent('deleteMapPins', {});\n      emitCustomEvent('showLoading', {});\n    \n      fetchFeatureData(selectedLayer, this.filterString)\n        .then(data => {\n          if (data && data.features) {\n            const translationKeys = Object.keys(this.keyTranslations);\n            \n            const sortedFeatures = data.features.map(feature => {\n              const filteredPropertyKeys = Object.keys(feature.properties)\n                .filter(key => !this.blockedKeys.includes(key))  // Filter out blocked keys\n                .sort((a, b) => {\n                  const indexA = translationKeys.indexOf(a);\n                  const indexB = translationKeys.indexOf(b);\n                  return (indexA !== -1 ? indexA : Infinity) - (indexB !== -1 ? indexB : Infinity);\n                });\n    \n              const sortedProperties = {};\n              filteredPropertyKeys.forEach(key => {\n                sortedProperties[key] = feature.properties[key];\n              });\n    \n              return { ...feature, properties: sortedProperties };\n            });\n    \n            // Apply additional processing if necessary, like filtering based on visibility\n            this.features = sortedFeatures;\n            this.fetchSuccessful = true;\n          } else {\n            this.fetchSuccessful = false;\n          }\n          emitCustomEvent('hideLoading', {});\n        })\n        .catch(error => {\n          console.error('Error:', error);\n          this.fetchSuccessful = false;\n        });\n    },\n    \n    \n    \n    \n  });\n\n\n  const domElementsToCreate = [ \n    [createMarkup, '#attributeTable']\n  ]\n  renderMarkupAndSetPluginReady(domElementsToCreate)\n\n\n  // Event listener for layer select change\n  document.getElementById('layerSelect').addEventListener('change', function() {\n    Alpine.store('attributeTable').updateTableForLayer(this.value);\n  });\n\n  // Event listener for upated filter\n  document.addEventListener('geonodeCustomLayerFilterUpdated', function (event) {\n    console.debug('Custom event \"geonodeCustomLayerFilterClosed\" caught.');\n    Alpine.store('attributeTable').filterString = Alpine.store('geonodeCustomLayerFilter').allFormValues['daard-database'];\n    Alpine.store('attributeTable').updateTableForLayer('Daard Database');\n  });\n};\n\n\nexport { initialize };"],"names":["Filter","tagName","Filter$1","LogicalNary","conditions","assert","LogicalNary$1","And","And$1","Bbox","geometryName","extent","srsName","Bbox$1","Comparison","propertyName","Comparison$1","ComparisonBinary","expression","matchCase","ComparisonBinary$1","EqualTo","EqualTo$1","Or","Or$1","and","params","or","bbox","equalTo","XML_SCHEMA_INSTANCE_URI","createElementNS","namespaceURI","qualifiedName","getDocument","getAllTextContent","node","normalizeWhitespace","getAllTextContent_","accumulator","n","isDocument","object","getAttributeNS","name","parse","xml","makeArrayExtender","valueReader","thisArg","objectStack","value","array","extend","makeArrayPusher","makeReplacer","makeObjectPropertySetter","property","makeChildAppender","nodeWriter","makeSimpleNodeFactory","fixedNodeName","fixedNamespaceURI","newNodeName","nodeName","OBJECT_PROPERTY_NODE_FACTORY","parseNode","parsersNS","parsers","parser","pushParseAndPop","serialize","serializersNS","nodeFactory","values","keys","length","i","pushSerializeAndPop","xmlSerializer_","getXMLSerializer","document_","XMLFeature","FeatureFormat","source","options","doc","features","abstract","feature","geometry","XMLFeature$1","GMLNS","ONLY_WHITESPACE_RE","GMLBase","localName","context","featureType","featureNS","prefix","defaultPrefix","ii","child","ft","key","count","uri","candidate","ns","featureTypes","p","transformExtentWithOptions","transformGeometryWithOptions","asFeature","len","attName","Feature","fid","flatCoordinates","Point","coordinates","MultiPoint","lineStrings","MultiLineString","polygons","MultiPolygon","LineString","ring","LinearRing","flatLinearRings","ends","Polygon","internalOptions","getProjection","GMLBase$1","readPositiveInteger","s","readNonNegativeIntegerString","string","m","writeStringTextNode","schemaLocation","MULTIGEOMETRY_TO_MEMBER_NODENAME","GML2","containerSrs","axisOrientation","proj","coordsGroups","coords","x","y","z","createOrUpdate","flatLinearRing","multiSurface","surface","multiCurve","properties","item","segments","line","hasZ","curve","lines","points","parts","point","rings","patches","parentNode","exteriorWritten","polygon","linearRing","coord","GML2$1","GML3","re","contextDimension","dim","srsDimension","pos","posList","serializers","geom","GML3$1","GML32","GML32$1","FEATURE_COLLECTION_PARSERS","TRANSACTION_SUMMARY_PARSERS","TRANSACTION_RESPONSE_PARSERS","readTransactionSummary","readInsertResults","QUERY_SERIALIZERS","TRANSACTION_SERIALIZERS","writeFeature","writeUpdate","writeDelete","writeProperty","writeNative","FEATURE_PREFIX","XMLNS","OGCNS","WFSNS","FESNS","SCHEMA_LOCATIONS","GML_FORMATS","DEFAULT_VERSION","WFS","featuresNS","result","filter","writeGetFeature","completeFilter","bboxFilter","bboxFilterFn","andFilterFn","inserts","updates","deletes","version","baseObj","request","createTransactionRequest","serializeTransactionRequest","featurePrefix","gmlVersion","type","OGC_FID_PARSERS","fidParser","INSERT_RESULTS_PARSERS","writeOgcFidFilter","getTypeName","typeName","pair","nativeElement","GETFEATURE_SERIALIZERS","writeQuery","writeDuringFilter","writeLogicalFilter","writeNotFilter","writeBboxFilter","writeSpatialFilter","writeDWithinFilter","writeComparisonFilter","writeIsNullFilter","writeIsBetweenFilter","writeIsLikeFilter","writeResourceIdFilter","propertyNames","typeNameAttr","getFilterNS","writeFilterCondition","parent","format","writePropertyName","distance","writeExpression","timePeriod","begin","writeTimeInstant","end","condition","writeLiteral","lowerBoundary","upperBoundary","time","timeInstant","timePosition","WFS$1","parseFilterCondition","match","fetchFeatureData","layerName","filterString","LayerParams","featureLayersGroup","layer","baseurl","getBaseUrl","featureRequestOptions","filters","singleFilter","featureRequest","response","createMarkup","attributeTableNaavigationBtn","rightMiddleSlot","attributeTableSlideOutHtml","mapDIV","initialize","Alpine","isValidUrl","emitCustomEvent","featureId","f","center","e","buffer","boundingExtent","getCenter","allPolygons","allLines","coordIndex","decorateValue","feather","query","filtered","start","paginated","filteredCount","page","pages","visibleLayers","selectedLayer","data","translationKeys","sortedFeatures","filteredPropertyKeys","a","b","indexA","indexB","sortedProperties","error","renderMarkupAndSetPluginReady","event"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]}