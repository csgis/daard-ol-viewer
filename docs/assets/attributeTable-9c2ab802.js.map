{"version":3,"file":"attributeTable-9c2ab802.js","sources":["../../node_modules/ol/xml.js","../../node_modules/ol/format/XMLFeature.js","../../node_modules/ol/format/GMLBase.js","../../node_modules/ol/format/xsd.js","../../node_modules/ol/format/GML2.js","../../node_modules/ol/format/GML3.js","../../node_modules/ol/format/GML32.js","../../node_modules/ol/format/filter/Filter.js","../../node_modules/ol/format/filter/LogicalNary.js","../../node_modules/ol/format/filter/And.js","../../node_modules/ol/format/filter/Bbox.js","../../node_modules/ol/format/filter.js","../../node_modules/ol/format/WFS.js","../../components/core/attributeTable/attributeTable.js"],"sourcesContent":["/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(\n      thisArg !== undefined ? thisArg : this,\n      node,\n      value,\n      objectStack\n    );\n    const parent = /** @type {NodeStackItem} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg !== undefined ? thisArg : this,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n","/**\n * @module ol/format/XMLFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\nimport {extend} from '../array.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeatureFromNode(/** @type {Element} */ (source), options);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeaturesFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options)\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readGeometryFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readProjectionFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n","/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport {extend} from '../array.js';\nimport {\n  getAllTextContent,\n  getAttributeNS,\n  makeArrayPusher,\n  makeReplacer,\n  parseNode,\n  pushParseAndPop,\n} from '../xml.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal),\n    };\n\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop(\n        [],\n        this.FEATURE_COLLECTION_PARSERS,\n        node,\n        objectStack,\n        this\n      );\n    } else if (\n      localName == 'featureMembers' ||\n      localName == 'featureMember' ||\n      localName == 'member'\n    ) {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        (featureType = []), (featureNS = {});\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */ (node.childNodes[i]);\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType)\n        ? featureType\n        : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':')\n            ? featureTypes[i].split(':')[0]\n            : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n              localName == 'featureMembers'\n                ? makeArrayPusher(this.readFeatureElement, this)\n                : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] =\n      node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const extent = /** @type {import(\"../extent.js\").Extent} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return geometry\n      ? transformGeometryWithOptions(geometry, false, context)\n      : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (\n        n.childNodes.length === 0 ||\n        (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))\n      ) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value =\n            localName === 'boundedBy'\n              ? this.readExtentElement(n, objectStack)\n              : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      const len = n.attributes.length;\n      if (len > 0) {\n        value = {_content_: value};\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    } else {\n      const feature = new Feature(values);\n      if (geometryName) {\n        feature.setGeometryName(geometryName);\n      }\n      const fid =\n        node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n      if (fid) {\n        feature.setId(fid);\n      }\n      return feature;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop(\n      [],\n      this.MULTIPOINT_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTILINESTRING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTIPOLYGON_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (ring) {\n      return ring;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [\n      this.getReadOptions(node, options ? options : {}),\n    ]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS,\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return getProjection(\n      this.srsName\n        ? this.srsName\n        : node.firstElementChild.getAttribute('srsName')\n    );\n  }\n}\n\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n  },\n};\n\nexport default GMLBase;\n","/**\n * @module ol/format/xsd\n */\nimport {getAllTextContent, getDocument} from '../xml.js';\nimport {padNumber} from '../string.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(getDocument().createTextNode(string));\n}\n","/**\n * @module ol/format/GML2\n */\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  createElementNS,\n  getAllTextContent,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {createOrUpdate} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport {writeStringTextNode} from './xsd.js';\n\n/**\n * @const\n * @type {string}\n */\nconst schemaLocation =\n  GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @api\n */\nclass GML2 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(\n      this.readFeaturesInternal\n    );\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatCoordinates(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n      objectStack[0]\n    );\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    const coordsGroups = s.trim().split(/\\s+/);\n    const flatCoordinates = [];\n    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n      const coords = coordsGroups[i].split(/,+/);\n      const x = parseFloat(coords[0]);\n      const y = parseFloat(coords[1]);\n      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readBox(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.BOX_PARSERS_,\n      node,\n      objectStack,\n      this\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[1][3],\n      flatCoordinates[1][4]\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  innerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  outerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml', nodeName);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @return {Element} coordinates node.\n   * @private\n   */\n  createCoordinatesNode_(namespaceURI) {\n    const coordinates = createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n\n    return coordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LineString.js\").default|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCoordinates_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      const point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs'\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ',' + point[1]\n        : point[1] + ',' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ',' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    const point = geometry.getCoordinates();\n    const coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates, coord);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      'http://www.opengis.net/gml',\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML2.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML2.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\nexport default GML2;\n","/**\n * @module ol/format/GML3\n */\nimport GML2 from './GML2.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {createOrUpdate} from '../extent.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation =\n  GMLNS +\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n  '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ =\n      options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ =\n      options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Polygon.\n   */\n  readFlatCurveRing(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    const flatCoordinates = [];\n    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n      extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTISURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.PATCHES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.SURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.CURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.ENVELOPE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[2][0],\n      flatCoordinates[2][1]\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n    ) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n      );\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ' ' + point[1]\n        : point[1] + ' ' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior'\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement,\n      this\n    );\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS),\n      features,\n      objectStack\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeGeometryNode(geometry, options) {\n    options = this.adaptOptions(options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Element} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation\n    );\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML3;\n","/**\n * @module ol/format/GML32\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase from './GMLBase.js';\nimport {\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n} from '../xml.js';\nimport {writeStringTextNode} from '../format/xsd.js';\n\n/**\n * @classdesc Feature format for reading and writing data in the GML format\n *            version 3.2.1.\n * @api\n */\nclass GML32 extends GML3 {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';\n  }\n}\n\nGML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML32.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML32.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML32.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML32.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML32.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML32.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml/3.2': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML32.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML32;\n","/**\n * @module ol/format/filter/Filter\n */\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature filters.\n *\n * @abstract\n */\nclass Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   */\n  constructor(tagName) {\n    /**\n     * @private\n     * @type {!string}\n     */\n    this.tagName_ = tagName;\n  }\n\n  /**\n   * The XML tag name for a filter.\n   * @return {!string} Name.\n   */\n  getTagName() {\n    return this.tagName_;\n  }\n}\n\nexport default Filter;\n","/**\n * @module ol/format/filter/LogicalNary\n */\nimport Filter from './Filter.js';\nimport {assert} from '../../asserts.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature n-ary logical filters.\n *\n * @abstract\n */\nclass LogicalNary extends Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {Array<import(\"./Filter.js\").default>} conditions Conditions.\n   */\n  constructor(tagName, conditions) {\n    super(tagName);\n\n    /**\n     * @type {Array<import(\"./Filter.js\").default>}\n     */\n    this.conditions = conditions;\n    assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n  }\n}\n\nexport default LogicalNary;\n","/**\n * @module ol/format/filter/And\n */\nimport LogicalNary from './LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<And>` operator between two or more filter conditions.\n *\n * @abstract\n */\nclass And extends LogicalNary {\n  /**\n   * @param {...import(\"./Filter.js\").default} conditions Conditions.\n   */\n  constructor(conditions) {\n    super('And', Array.prototype.slice.call(arguments));\n  }\n}\n\nexport default And;\n","/**\n * @module ol/format/filter/Bbox\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @api\n */\nclass Bbox extends Filter {\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../../extent.js\").Extent} extent Extent.\n   * @param {string} [srsName] SRS name. No srsName attribute will be set\n   * on geometries when this is not provided.\n   */\n  constructor(geometryName, extent, srsName) {\n    super('BBOX');\n\n    /**\n     * @type {!string}\n     */\n    this.geometryName = geometryName;\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.extent = extent;\n    if (extent.length !== 4) {\n      throw new Error(\n        'Expected an extent with four values ([minX, minY, maxX, maxY])'\n      );\n    }\n\n    /**\n     * @type {string|undefined}\n     */\n    this.srsName = srsName;\n  }\n}\n\nexport default Bbox;\n","/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport DWithin from './filter/DWithin.js';\nimport Disjoint from './filter/Disjoint.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport ResourceId from './filter/ResourceId.js';\nimport Within from './filter/Within.js';\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @return {!And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params))();\n}\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @return {!Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params))();\n}\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @return {!Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, srsName) {\n  return new Bbox(geometryName, extent, srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, srsName) {\n  return new Contains(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, srsName) {\n  return new Intersects(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<Disjoint>` operator to test whether a geometry-valued property\n * is disjoint to a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Disjoint} `<Disjoint>` operator.\n * @api\n */\nexport function disjoint(geometryName, geometry, srsName) {\n  return new Disjoint(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, srsName) {\n  return new Within(geometryName, geometry, srsName);\n}\n\n/**\n * Create a `<DWithin>` operator to test whether a geometry-valued property\n * is within a distance to a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {!number} distance Distance.\n * @param {!string} unit Unit.\n * @param {string} [srsName] SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @return {!DWithin} `<DWithin>` operator.\n * @api\n */\nexport function dwithin(geometryName, geometry, distance, unit, srsName) {\n  return new DWithin(geometryName, geometry, distance, unit, srsName);\n}\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean} [matchCase] Case-sensitive?\n * @return {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, matchCase) {\n  return new EqualTo(propertyName, expression, matchCase);\n}\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean} [matchCase] Case-sensitive?\n * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, matchCase) {\n  return new NotEqualTo(propertyName, expression, matchCase);\n}\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @return {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @return {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string} [wildCard] Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string} [singleChar] pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string} [escapeChar] Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean} [matchCase] Case-sensitive?\n * @return {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(\n  propertyName,\n  pattern,\n  wildCard,\n  singleChar,\n  escapeChar,\n  matchCase\n) {\n  return new IsLike(\n    propertyName,\n    pattern,\n    wildCard,\n    singleChar,\n    escapeChar,\n    matchCase\n  );\n}\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @return {!During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n\nexport function resourceId(rid) {\n  return new ResourceId(rid);\n}\n","/**\n * @module ol/format/WFS\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GML32 from './GML32.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  isDocument,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeSimpleNodeFactory,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {and as andFilterFn, bbox as bboxFilterFn} from './filter.js';\nimport {assert} from '../asserts.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readNonNegativeIntegerString,\n  readPositiveInteger,\n  writeStringTextNode,\n} from './xsd.js';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readExtentElement,\n      'bounds'\n    ),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'member': makeArrayPusher(GMLBase.prototype.readFeaturesInternal),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary'\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary'\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n};\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.\n * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to\n * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are\n * ignored.).\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`\n * option must be set.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} FeatureType\n * @property {!string} name The feature type name.\n * @property {!import(\"../extent.js\").Extent} bbox Extent to use for the BBOX filter.\n * @property {!string} geometryName Geometry name to use in the BBOX filter.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures NumberOfFeatures.\n * @property {import(\"../extent.js\").Extent} bounds Bounds.\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted TotalDeleted.\n * @property {number} totalInserted TotalInserted.\n * @property {number} totalUpdated TotalUpdated.\n * @property {Array<string>} insertIds InsertIds.\n */\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @type {Object<string, string>}\n */\nconst OGCNS = {\n  '2.0.0': 'http://www.opengis.net/ogc/1.1',\n  '1.1.0': 'http://www.opengis.net/ogc',\n  '1.0.0': 'http://www.opengis.net/ogc',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst WFSNS = {\n  '2.0.0': 'http://www.opengis.net/wfs/2.0',\n  '1.1.0': 'http://www.opengis.net/wfs',\n  '1.0.0': 'http://www.opengis.net/wfs',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst FESNS = {\n  '2.0.0': 'http://www.opengis.net/fes/2.0',\n  '1.1.0': 'http://www.opengis.net/fes',\n  '1.0.0': 'http://www.opengis.net/fes',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '2.0.0':\n    'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',\n  '1.1.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd',\n};\n\n/**\n * @type {Object<string, object>}\n */\nconst GML_FORMATS = {\n  '2.0.0': GML32,\n  '1.1.0': GML3,\n  '1.0.0': GML2,\n};\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option to override the default.\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version ? options.version : DEFAULT_VERSION;\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat\n      ? options.gmlFormat\n      : new GML_FORMATS[this.version_]();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation\n      ? options.schemaLocation\n      : SCHEMA_LOCATIONS[this.version_];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    Object.assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_,\n    });\n\n    Object.assign(context, this.getReadOptions(node, options ? options : {}));\n    const objectStack = [context];\n    let featuresNS;\n    if (this.version_ === '2.0.0') {\n      featuresNS = FEATURE_COLLECTION_PARSERS;\n    } else {\n      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;\n    }\n    let features = pushParseAndPop(\n      [],\n      featuresNS,\n      node,\n      objectStack,\n      this.gmlFormat_\n    );\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readTransactionResponseFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(\n          /** @type {Element} */ (n)\n        );\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures')\n    );\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS,\n      node,\n      [],\n      this.gmlFormat_\n    );\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {TransactionResponse} */ ({}),\n      TRANSACTION_RESPONSE_PARSERS,\n      node,\n      []\n    );\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS[this.version_], 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', this.version_);\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n    if (options.outputFormat) {\n      node.setAttribute('outputFormat', options.outputFormat);\n    }\n    if (options.maxFeatures !== undefined) {\n      node.setAttribute('maxFeatures', String(options.maxFeatures));\n    }\n    if (options.resultType) {\n      node.setAttribute('resultType', options.resultType);\n    }\n    if (options.startIndex !== undefined) {\n      node.setAttribute('startIndex', String(options.startIndex));\n    }\n    if (options.count !== undefined) {\n      node.setAttribute('count', String(options.count));\n    }\n    if (options.viewParams !== undefined) {\n      node.setAttribute('viewParams', options.viewParams);\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation_\n    );\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    Object.assign(context, {\n      'version': this.version_,\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'propertyNames': options.propertyNames ? options.propertyNames : [],\n    });\n    assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` must be an Array\n    if (typeof options.featureTypes[0] === 'string') {\n      let filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\n        filter = this.combineBboxAndFilter(\n          options.geometryName,\n          options.bbox,\n          options.srsName,\n          filter\n        );\n      }\n      Object.assign(context, {\n        'geometryName': options.geometryName,\n        'filter': filter,\n      });\n      writeGetFeature(\n        node,\n        /** @type {!Array<string>} */ (options.featureTypes),\n        [context]\n      );\n    } else {\n      // Write one query node per element in featuresType.\n      options.featureTypes.forEach((/** @type {FeatureType} */ featureType) => {\n        const completeFilter = this.combineBboxAndFilter(\n          featureType.geometryName,\n          featureType.bbox,\n          options.srsName,\n          options.filter\n        );\n        Object.assign(context, {\n          'geometryName': featureType.geometryName,\n          'filter': completeFilter,\n        });\n        writeGetFeature(node, [featureType.name], [context]);\n      });\n    }\n    return node;\n  }\n\n  /**\n   * Create a bbox filter and combine it with another optional filter.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../extent.js\").Extent} extent Extent.\n   * @param {string} [srsName] SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @param {import(\"./filter/Filter.js\").default} [filter] Filter condition.\n   * @return {import(\"./filter/Filter.js\").default} The filter.\n   */\n  combineBboxAndFilter(geometryName, extent, srsName, filter) {\n    const bboxFilter = bboxFilterFn(geometryName, extent, srsName);\n    if (filter) {\n      // if bbox and filter are both set, combine the two into a single filter\n      return andFilterFn(filter, bboxFilter);\n    }\n    return bboxFilter;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const version = options.version ? options.version : this.version_;\n    const node = createElementNS(WFSNS[version], 'Transaction');\n\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATIONS[version]\n    );\n\n    const request = createTransactionRequest(node, baseObj, version, options);\n    if (inserts) {\n      serializeTransactionRequest('Insert', inserts, objectStack, request);\n    }\n    if (updates) {\n      serializeTransactionRequest('Update', updates, objectStack, request);\n    }\n    if (deletes) {\n      serializeTransactionRequest('Delete', deletes, objectStack, request);\n    }\n    if (options.nativeElements) {\n      serializeTransactionRequest(\n        'Native',\n        options.nativeElements,\n        objectStack,\n        request\n      );\n    }\n    return node;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (\n          !(\n            n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 && n.firstChild.nodeType === 3)\n          )\n        ) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {*} baseObj Base object.\n * @param {string} version Version.\n * @param {WriteTransactionOptions} options Options.\n * @return {Object} Request object.\n */\nfunction createTransactionRequest(node, baseObj, version, options) {\n  const featurePrefix = options.featurePrefix\n    ? options.featurePrefix\n    : FEATURE_PREFIX;\n  let gmlVersion;\n  if (version === '1.0.0') {\n    gmlVersion = 2;\n  } else if (version === '1.1.0') {\n    gmlVersion = 3;\n  } else if (version === '2.0.0') {\n    gmlVersion = 3.2;\n  }\n  const obj = Object.assign(\n    {node},\n    {\n      version,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'hasZ': options.hasZ,\n      'srsName': options.srsName,\n    },\n    baseObj\n  );\n  return obj;\n}\n\n/**\n * @param {string} type Request type.\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @param {Element} request Transaction Request.\n */\nfunction serializeTransactionRequest(type, features, objectStack, request) {\n  pushSerializeAndPop(\n    request,\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory(type),\n    features,\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n  'http://www.opengis.net/ogc/1.1': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser,\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Feature': fidParser,\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else if (gmlVersion === 3) {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML32.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = OGCNS[version];\n  const filter = createElementNS(ns, 'Filter');\n  const child = createElementNS(ns, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */ (fid));\n  node.appendChild(filter);\n}\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @return {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.startsWith(prefix)) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const version = context['version'];\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (\n          value &&\n          typeof (/** @type {?} */ (value).getSimplifiedGeometry) === 'function'\n        ) {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */ ({\n        version,\n        'gmlVersion': context['gmlVersion'],\n        node,\n        'hasZ': context['hasZ'],\n        'srsName': context['srsName'],\n      }),\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Property'),\n      values,\n      objectStack\n    );\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = WFSNS[version];\n  const name = createElementNS(ns, 'Name');\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(ns, 'Value');\n    node.appendChild(value);\n    if (\n      pair.value &&\n      typeof (/** @type {?} */ (pair.value).getSimplifiedGeometry) ===\n        'function'\n    ) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else if (gmlVersion === 3) {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML32.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n  'http://www.opengis.net/fes/2.0': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Disjoint': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'ResourceId': makeChildAppender(writeResourceIdFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const version = context['version'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  let typeNameAttr;\n  if (version === '2.0.0') {\n    typeNameAttr = 'typeNames';\n  } else {\n    typeNameAttr = 'typeName';\n  }\n  node.setAttribute(typeNameAttr, typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    Object.assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'),\n    propertyNames,\n    objectStack\n  );\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(getFilterNS(version), 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter],\n    objectStack\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n/**\n * @param {Element} node Element.\n * @param {import(\"./filter/ResourceId.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeResourceIdFilter(node, filter, objectStack) {\n  node.setAttribute('rid', /** @type {string} */ (filter.rid));\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Spatial.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeSpatialFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/DWithin.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDWithinFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writeSpatialFilter(node, filter, objectStack);\n  const distance = createElementNS(getFilterNS(version), 'Distance');\n  writeStringTextNode(distance, filter.distance.toString());\n  if (version === '2.0.0') {\n    distance.setAttribute('uom', filter.unit);\n  } else {\n    distance.setAttribute('units', filter.unit);\n  }\n  node.appendChild(distance);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n\n  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(\n      item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition],\n      objectStack\n    );\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  const condition = filter.condition;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition],\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.expression);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writePropertyName(version, node, filter.propertyName);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  const ns = getFilterNS(version);\n\n  writePropertyName(version, node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(ns, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(ns, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.pattern);\n}\n\n/**\n * @param {string} ns Namespace.\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeExpression(ns, tagName, node, value) {\n  const property = createElementNS(ns, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeLiteral(version, node, value) {\n  writeExpression(getFilterNS(version), 'Literal', node, value);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writePropertyName(version, node, value) {\n  if (version === '2.0.0') {\n    writeExpression(FESNS[version], 'ValueReference', node, value);\n  } else {\n    writeExpression(OGCNS[version], 'PropertyName', node, value);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {string} version WFS version. If not provided defaults to '1.1.0'\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter, version) {\n  version = version || '1.1.0';\n  const child = createElementNS(getFilterNS(version), 'Filter');\n  const context = {\n    node: child,\n  };\n  Object.assign(context, {\n    'version': version,\n    'filter': filter,\n  });\n  writeFilterCondition(child, filter, [context]);\n  return child;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    Object.assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'),\n    featureTypes,\n    objectStack\n  );\n}\n\nfunction getFilterNS(version) {\n  let ns;\n  if (version === '2.0.0') {\n    ns = FESNS[version];\n  } else {\n    ns = OGCNS[version];\n  }\n  return ns;\n}\n\nexport default WFS;\n","import './attributeTable.css';\n\nimport { boundingExtent, getCenter } from 'ol/extent';\nimport { emitCustomEvent, getBaseUrl, isValidUrl } from '../helper.js'\nimport { featureLayersGroup, map } from '../mapSetup/mapSetup.js'\n\nimport Alpine from 'alpinejs';\nimport { WFS } from 'ol/format';\nimport { addClickIndicator } from '../clickIndicator/clickIndicator.js';\nimport { decorateValue } from '../contentDecorator/contentDecorator.js';\nimport feather from 'feather-icons';\nimport {renderMarkupAndSetPluginReady} from '../helper.js'\n\n// Function to fetch feature data from WFS\nconst fetchFeatureData = (layerName) => {\n  const Layer = featureLayersGroup.getLayers().getArray().find(layer => layer.get('name') === layerName);\n\n  \n  const LayerParams = Layer.getSource().getParams().LAYERS;\n\n  const baseurl = getBaseUrl(featureLayersGroup.getLayers().getArray().find(layer => layer.get('name') === layerName).getSource().url_);\n\n  const featureRequest = new WFS().writeGetFeature({\n    srsName: 'EPSG:3857',\n    featurePrefix: 'geonode',\n    featureTypes: [LayerParams],\n    outputFormat: 'application/json',\n  });\n\n  return fetch(`${baseurl}wfs`, {\n    method: 'POST',\n    body: new XMLSerializer().serializeToString(featureRequest),\n    headers: {\n      'Content-Type': 'text/xml',\n    },\n  })\n  .then(response => response.json());\n}\n\nconst createMarkup = () => {\n  // Plugin HTML Markup\n  const attributeTableNaavigationBtn = `\n      <div class=\"mx-1  order-2\">\n      <button\n        type=\"button\" \n        class=\"btn btn-danger btn-sm btn-circle\" \n        id=\"attributeTableBtn\" \n        x-tooltip.placement.left=\"'Attribute table'\"\n        @click=\"$store.attributeTable.process_attribute_table()\"\n        :class=\"$store.attributeTable.componentIsActive ? 'bg-danger' : 'btn-light'\">\n        <i data-feather=\"list\" class=\"size-16\"></i>\n\n      </button>\n    </div>\n      `\n\n  var rightMiddleSlot = document.getElementById('rightMiddleSlot');\n  rightMiddleSlot.insertAdjacentHTML('beforeend', attributeTableNaavigationBtn);\n\n  const attributeTableSlideOutHtml = `\n    <div id=\"attributeTable\" class=\"position-absolute bottom-0 end-0 p-0 bg-white border-top px-1\" style=\"width: 100%; height: 40vh; z-index:1000\" x-show=\"$store.attributeTable.componentIsActive\">\n      <div class=\"offcanvas-header d-flex justify-content-between align-items-center px-3 mt-3\">\n          <div class=\"d-flex align-items-center\">\n              <!-- Layer Selection -->\n              <div class=\"layer-select-container me-2\">\n                  <select id=\"layerSelect\" class=\"form-select form-select-sm\">\n                      <template x-for=\"option in $store.attributeTable.visisbleLayers\">\n                          <option :value=\"option.get('name')\" x-text=\"option.get('name')\"></option>\n                      </template>\n                  </select>\n              </div>\n              <!-- Row Count Selection -->\n              <div class=\"ms-2\">\n                  <select x-model=\"$store.attributeTable.rowCount\" class=\"form-select form-select-sm\" id=\"rowCountSelect\">\n                      <option value=\"5\">5</option>\n                      <option value=\"10\">10</option>\n                      <option value=\"50\">50</option>\n                  </select>\n              </div>\n          </div>\n\n          <div class=\"d-flex align-items-center\">\n              <!-- Items Shown Indicator -->\n              <p class=\"mb-0 mx-3\" x-text=\"$store.attributeTable.filteredFeatures().length + ' items shown'\"></p>\n           \n              <!-- Search Input -->\n              <div class=\"d-flex me-2\">\n                  <label for=\"searchInput\" class=\"me-2 mb-0\"><i class=\"bi bi-search\"></i></label>\n                  <input type=\"text\" id=\"searchInput\" class=\"form-control form-control-sm\" placeholder=\"Search...\" x-model=\"$store.attributeTable.searchQuery\" style=\"width: 200px;\">\n              </div>\n\n              <!-- Close Button -->\n              <button type=\"button\" class=\"btn-close\" aria-label=\"Close\" @click=\"$store.attributeTable.closePanel()\"></button>\n          </div>\n      </div>\n\n\n            <div class=\"offcanvas-body mt-4 px-3\" id=\"attributeTableBody\">\n\n              <!-- table -->\n              <div style=\"width: 100%; overflow-y: auto;\">\n\n              <!-- Alpine.js Component for Feature Properties Table -->\n              <div x-cloak>\n                <template x-if=\"!$store.attributeTable.fetchSuccessful\">\n                  <p>Sorry, no items received.</p>\n                </template>\n\n                <template x-if=\"$store.attributeTable.fetchSuccessful\">\n                  <table class=\"attributesTable table table-sm table-striped mb-0\" id=\"attributesTable\">\n                    <thead>\n                        <tr>\n                          <th>\n                            <span class=\"attributTable_col\" x-text=\"'zoom to'\"></span>\n                          </th>\n                          <template x-if=\"$store.attributeTable.features.length > 0\">\n                            <template x-for=\"key in Object.keys($store.attributeTable.features[0].properties)\" :key=\"key\">\n                              <th>\n                                <span class=\"attributTable_col\" x-text=\"key\"></span>\n                              </th>\n                            </template>\n                          </template>\n                        </tr>\n                      </thead>\n                      <tbody>\n                          <template x-for=\"feature in $store.attributeTable.paginatedFeatures()\" :key=\"feature.id\">\n                          <tr :class=\"$store.attributeTable.activeFeatures.includes(String(feature.properties['fid'])) ? 'highlight-row' : ''\">\n                            <td>\n                            <p x-show=\"!$store.attributeTable.activeFeatures.includes(String(feature.properties['fid']))\">\n                              <a href=\"#\" :data-id=\"feature.properties['fid']\" @click=\"$store.attributeTable.zoomTo()\" >\n                                  <i data-feather=\"map-pin\" class=\"size-16\"></i>\n                              </a>      \n                            </p>\n\n                            <p x-show=\"$store.attributeTable.activeFeatures.includes(String(feature.properties['fid']))\">\n                              <a href=\"#\" :data-id=\"feature.properties['fid']\" @click=\"$store.attributeTable.zoomTo()\" >\n                                <i data-feather=\"check\" class=\"size-16\"></i>\n                              </a>      \n                            </p>\n\n                            </td>\n                            <template x-for=\"[key, value] in Object.entries(feature.properties)\" :key=\"key\">\n                              <td>\n                                <span class=\"attributTable_col\" x-html=\"$store.attributeTable.decorateValue(value)\"> </span>\n                              </td>\n                            </template>\n                          </tr>\n                        </template>\n                      </tbody>\n                  </table>\n                </template>\n                \n              </div>\n\n\n            \n            </div>\n            <!-- Pagination -->\n            <template x-if=\"$store.attributeTable.fetchSuccessful\">\n\n              <nav aria-label=\"Page navigation\">\n                <ul class=\"pagination pagination-sm justify-content-end mt-3\">\n                  <!-- First Page Link -->\n                  <li class=\"page-item\" :class=\"{ disabled: $store.attributeTable.currentPage === 1 }\">\n                    <a class=\"page-link\" href=\"#\" @click.prevent=\"$store.attributeTable.setFirstPage()\">\n                      First\n                    </a>\n                  </li>\n              \n                  <!-- Dynamic Page Links -->\n                  <template x-for=\"page in $store.attributeTable.pageRange()\" :key=\"page\">\n                    <li class=\"page-item\" :class=\"{ active: $store.attributeTable.currentPage === page }\">\n                      <a class=\"page-link\" href=\"#\" x-text=\"page\" @click.prevent=\"$store.attributeTable.setPage(page)\">\n                      </a>\n                    </li>\n                  </template>\n              \n                  <!-- Last Page Link -->\n                  <li class=\"page-item\" :class=\"{ disabled: $store.attributeTable.currentPage === $store.attributeTable.totalPages() }\">\n                    <a class=\"page-link\" href=\"#\" @click.prevent=\"$store.attributeTable.setLastPage()\">\n                      Last\n                    </a>\n                  </li>\n                </ul>\n              </nav>\n              </template>\n    </div>\n  </div>\n\n  `\n  var mapDIV = document.getElementById('map');\n  mapDIV.insertAdjacentHTML('afterend', attributeTableSlideOutHtml);\n\n\n}\n\n\n// Initialize the plugin\nconst initialize = () => {\n\n\n  Alpine.store('attributeTable', {\n    componentIsActive: false,\n    visisbleLayers: [],\n    features: [],\n    activeFeatures: [],\n    isValidUrl: function(value){\n      return isValidUrl(value);\n    },\n\n    zoomToCoordinates: [],\n    closePanel: function(){\n      emitCustomEvent('deleteMapPins', {});\n      this.componentIsActive = false;\n      this.activeFeatures = [];\n      this.zoomToCoordinates = [];\n      Alpine.store('pluginStatus').mapClickEnabled = true;\n\n    },\n    zoomTo: function(){\n        const featureId = event.target.closest('a').getAttribute(\"data-id\")\n        const feature = this.features.find(f => f.properties['fid'] == featureId);\n\n        if (feature) {\n          const geometry = feature.geometry;\n          let extent;\n          let center;\n          if (this.activeFeatures.includes(featureId)) {\n              this.activeFeatures = this.activeFeatures.filter(function(e) { return e !== featureId })\n          } else {\n              this.activeFeatures.push(featureId);\n          }\n\n    \n          switch (geometry.type) {\n            case 'Point':\n              center = geometry.coordinates;\n              const buffer = 100; // Adjust buffer size as needed\n              extent = [\n                geometry.coordinates[0] - buffer, \n                geometry.coordinates[1] - buffer, \n                geometry.coordinates[0] + buffer, \n                geometry.coordinates[1] + buffer\n              ];\n              var maxZoom = 13;\n              break;\n    \n            case 'Polygon':\n              extent = boundingExtent(geometry.coordinates[0].flat());\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            case 'MultiPolygon':\n              const allPolygons = geometry.coordinates.flat(2);\n              extent = boundingExtent(allPolygons);\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            case 'LineString':\n              extent = boundingExtent(geometry.coordinates);\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            case 'MultiLineString':\n              const allLines = geometry.coordinates.flat();\n              extent = boundingExtent(allLines);\n              center = getCenter(extent);\n              var maxZoom = 15;\n              break;\n    \n            default:\n              console.error('Unsupported geometry type:', geometry.type);\n              return;\n          }\n    \n          if (extent) {\n\n            const coordIndex = this.zoomToCoordinates.findIndex(coord => \n                coord[0] === center[0] && coord[1] === center[1]\n            );\n\n            if (coordIndex === -1) {\n                // Coordinate not found, add it\n                this.zoomToCoordinates.push([center[0], center[1]]);\n            } else {\n                // Coordinate found, remove it\n                this.zoomToCoordinates.splice(coordIndex, 1);\n            }\n\n            emitCustomEvent('deleteMapPins', {});\n            emitCustomEvent('addMapPins', {\"pin_coordinates\": this.zoomToCoordinates, \"fitView\": true, moveCenterLeft: false, bottomPadding: '40vh'});\n        }\n        }\n      \n    },\n    searchQuery: '',\n    rowCount: 5,\n    currentPage: 1,\n    fetchSuccessful: false,\n    decorateValue: function(value) {\n      const decoratedValue = decorateValue(value, ['createLinkForUrl', 'decodeUrl']);\n      return decoratedValue;\n    },\n   // This function should now only filter features based on the search query\n    filteredFeatures: function() {\n      feather.replace();\n\n      const query = this.searchQuery.toLowerCase();\n      const filtered = this.features.filter(feature => {\n        return Object.entries(feature.properties).some(([key, value]) => {\n          if (typeof value === 'string' || typeof value === 'number') {\n            return value.toString().toLowerCase().includes(query);\n          }\n          return false;\n        });\n      });\n\n      console.log(`Filtered Features: Query = '${query}', Count = ${filtered.length}`);\n      return filtered;\n    },\n\n    // New function to get the features for the current page\n    paginatedFeatures: function() {\n      const start = (this.currentPage - 1) * this.rowCount;\n      const end = start + Number(this.rowCount);\n      const paginated = this.filteredFeatures().slice(start, end);\n      console.log(`Paginated Features: Current Page = ${this.currentPage}, Row Count = ${this.rowCount}, Start = ${start}, End = ${end}, Count = ${paginated.length}`);\n      return paginated;\n    },\n\n    // Adjust totalPages to use the length of filteredFeatures instead of paginatedFeatures\n    totalPages: function() {\n      const filteredCount = this.filteredFeatures().length;\n      return Math.ceil(filteredCount / this.rowCount);\n    },\n    setPage: function(page) {\n      this.currentPage = page;\n    },\n\n    pageRange: function() {\n      const range = 2; // Number of pages to display around the current page\n      const start = Math.max(1, this.currentPage - range);\n      const end = Math.min(this.totalPages(), this.currentPage + range);\n      let pages = [];\n  \n      for (let i = start; i <= end; i++) {\n        pages.push(i);\n      }\n  \n      return pages;\n    },\n  \n    setFirstPage: function() {\n      this.currentPage = 1;\n    },\n  \n    setPage: function(page) {\n      this.currentPage = page;\n      console.log(`Set Page: Current Page Set to = ${page}`);\n    },\n    \n    process_attribute_table: function() {\n      Alpine.store('pluginStatus').closeAllOffcanvas('attributeTable');\n      this.componentIsActive = !this.componentIsActive;\n      Alpine.store('pluginStatus').mapClickEnabled = this.componentIsActive ? false : true;\n\n      this.populateLayerSelect();\n    },\n\n    populateLayerSelect: function() {\n      const visibleLayers = featureLayersGroup.getLayers().getArray().filter(layer => layer.getVisible());\n      this.visisbleLayers = visibleLayers;\n      if (visibleLayers.length > 0) {\n        this.selectedLayer = visibleLayers[0].get('name');\n        this.updateTableForLayer(this.selectedLayer); // Load table for the first layer\n      }\n    },\n\n    updateRowCount: function() {\n      this.currentPage = 1;\n      console.log(`Row Count Updated: New Row Count = ${this.rowCount}, Current Page Reset to = ${this.currentPage}`);\n    },\n\n    updateTableForLayer: function(layerName = null) {\n      this.currentTable = true;\n      const selectedLayer = layerName || document.getElementById('layerSelect').value;\n      const Layer = featureLayersGroup.getLayers().getArray().find(layer => layer.get('name') === selectedLayer);\n    \n      this.activeFeatures = [];\n      this.zoomToCoordinates = [];\n      emitCustomEvent('deleteMapPins', {});\n      emitCustomEvent('showLoading', {});\n\n      fetchFeatureData(selectedLayer)\n        .then(data => {\n          if (data && data.features) {\n            if (Layer.get('dataset') && Layer.get('dataset')['attribute_set']) {\n              // Filter features based on the visibility defined in the dataset\n              const visibleAttributes = Layer.get('dataset')['attribute_set'].filter(attr => attr.visible).map(attr => attr.attribute);\n              this.features = data.features.map(feature => {\n                const filteredProperties = {};\n                visibleAttributes.forEach(attr => {\n                  if (feature.properties.hasOwnProperty(attr)) {\n                    filteredProperties[attr] = feature.properties[attr];\n                  }\n                });\n                return { ...feature, properties: filteredProperties };\n              });\n            } else {\n              // No dataset defined, use all features\n              this.features = data.features;\n            }\n            this.fetchSuccessful = true;\n          } else {\n            this.fetchSuccessful = false;\n          }\n          emitCustomEvent('hideLoading', {});\n\n        })\n        .catch(error => {\n          console.error('Error:', error);\n          this.fetchSuccessful = false;\n        });\n    },\n    \n  });\n\n\n  const domElementsToCreate = [ \n    [createMarkup, '#attributeTable']\n  ]\n  renderMarkupAndSetPluginReady(domElementsToCreate)\n\n\n  // Event listener for layer select change\n  document.getElementById('layerSelect').addEventListener('change', function() {\n    Alpine.store('attributeTable').updateTableForLayer(this.value);\n  });\n\n};\n\n\nexport { initialize };"],"names":["XML_SCHEMA_INSTANCE_URI","createElementNS","namespaceURI","qualifiedName","getDocument","getAllTextContent","node","normalizeWhitespace","getAllTextContent_","accumulator","n","isDocument","object","getAttributeNS","name","parse","xml","makeArrayExtender","valueReader","thisArg","objectStack","value","array","extend","makeArrayPusher","makeReplacer","makeObjectPropertySetter","property","makeChildAppender","nodeWriter","makeSimpleNodeFactory","fixedNodeName","fixedNamespaceURI","newNodeName","nodeName","OBJECT_PROPERTY_NODE_FACTORY","parseNode","parsersNS","parsers","parser","pushParseAndPop","serialize","serializersNS","nodeFactory","values","keys","length","i","pushSerializeAndPop","xmlSerializer_","getXMLSerializer","document_","XMLFeature","FeatureFormat","source","options","doc","features","abstract","feature","geometry","XMLFeature$1","GMLNS","ONLY_WHITESPACE_RE","GMLBase","localName","context","featureType","featureNS","prefix","defaultPrefix","ii","child","ft","key","count","uri","candidate","ns","featureTypes","p","extent","transformExtentWithOptions","transformGeometryWithOptions","asFeature","geometryName","len","attName","Feature","fid","flatCoordinates","Point","coordinates","MultiPoint","lineStrings","MultiLineString","polygons","MultiPolygon","LineString","ring","LinearRing","flatLinearRings","ends","Polygon","internalOptions","getProjection","GMLBase$1","readPositiveInteger","s","readNonNegativeIntegerString","string","m","writeStringTextNode","schemaLocation","MULTIGEOMETRY_TO_MEMBER_NODENAME","GML2","containerSrs","axisOrientation","proj","coordsGroups","coords","x","y","z","createOrUpdate","flatLinearRing","multiSurface","surface","multiCurve","properties","item","srsName","segments","line","hasZ","curve","lines","points","parts","point","rings","patches","parentNode","exteriorWritten","polygon","linearRing","coord","GML2$1","GML3","re","contextDimension","dim","srsDimension","pos","posList","serializers","geom","GML3$1","GML32","GML32$1","Filter","tagName","Filter$1","LogicalNary","conditions","assert","LogicalNary$1","And","And$1","Bbox","Bbox$1","and","params","bbox","FEATURE_COLLECTION_PARSERS","TRANSACTION_SUMMARY_PARSERS","TRANSACTION_RESPONSE_PARSERS","readTransactionSummary","readInsertResults","QUERY_SERIALIZERS","TRANSACTION_SERIALIZERS","writeFeature","writeUpdate","writeDelete","writeProperty","writeNative","FEATURE_PREFIX","XMLNS","OGCNS","WFSNS","FESNS","SCHEMA_LOCATIONS","GML_FORMATS","DEFAULT_VERSION","WFS","featuresNS","result","filter","writeGetFeature","completeFilter","bboxFilter","bboxFilterFn","andFilterFn","inserts","updates","deletes","version","baseObj","request","createTransactionRequest","serializeTransactionRequest","featurePrefix","gmlVersion","type","OGC_FID_PARSERS","fidParser","INSERT_RESULTS_PARSERS","writeOgcFidFilter","getTypeName","typeName","pair","nativeElement","GETFEATURE_SERIALIZERS","writeQuery","writeDuringFilter","writeLogicalFilter","writeNotFilter","writeBboxFilter","writeSpatialFilter","writeDWithinFilter","writeComparisonFilter","writeIsNullFilter","writeIsBetweenFilter","writeIsLikeFilter","writeResourceIdFilter","propertyNames","typeNameAttr","getFilterNS","writeFilterCondition","parent","format","writePropertyName","distance","writeExpression","timePeriod","begin","writeTimeInstant","end","condition","writeLiteral","lowerBoundary","upperBoundary","time","timeInstant","timePosition","WFS$1","fetchFeatureData","layerName","LayerParams","featureLayersGroup","layer","baseurl","getBaseUrl","featureRequest","response","createMarkup","attributeTableNaavigationBtn","rightMiddleSlot","attributeTableSlideOutHtml","mapDIV","initialize","Alpine","isValidUrl","emitCustomEvent","featureId","f","center","e","buffer","boundingExtent","getCenter","allPolygons","allLines","coordIndex","decorateValue","feather","query","filtered","start","paginated","filteredCount","page","pages","visibleLayers","selectedLayer","Layer","data","visibleAttributes","attr","filteredProperties","error","renderMarkupAndSetPluginReady"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}